import{_ as e,o as t,c as a,Q as r}from"./chunks/framework.1eafcbb1.js";const p=JSON.parse('{"title":"Vue3 基礎","description":"","frontmatter":{},"headers":[],"relativePath":"workshop/vue3/mvvm.md","filePath":"workshop/vue3/mvvm.md"}'),l={name:"workshop/vue3/mvvm.md"},i=r('<h1 id="vue3-基礎" tabindex="-1">Vue3 基礎 <a class="header-anchor" href="#vue3-基礎" aria-label="Permalink to &quot;Vue3 基礎&quot;">​</a></h1><h2 id="宣告式渲染-vs-指令式渲染" tabindex="-1">宣告式渲染 VS 指令式渲染 <a class="header-anchor" href="#宣告式渲染-vs-指令式渲染" aria-label="Permalink to &quot;宣告式渲染 VS 指令式渲染&quot;">​</a></h2><h3 id="宣告式渲染-declarative-rendering" tabindex="-1">宣告式渲染（Declarative Rendering）： <a class="header-anchor" href="#宣告式渲染-declarative-rendering" aria-label="Permalink to &quot;宣告式渲染（Declarative Rendering）：&quot;">​</a></h3><ul><li>說明：以描述性的方式定義了所需的結果，而不需要詳細的操作步驟。</li><li>代表：是React、Vue.js等前端框架，以及HTML和CSS的使用方式。</li><li>例如：使用Vue.js的模板語法來描述UI，Vue.js負責處理DOM更新。</li></ul><h3 id="指令式渲染-imperative-rendering" tabindex="-1">指令式渲染（Imperative Rendering）： <a class="header-anchor" href="#指令式渲染-imperative-rendering" aria-label="Permalink to &quot;指令式渲染（Imperative Rendering）：&quot;">​</a></h3><ul><li>說明：需要明確的指令和操作來達到所需的結果。</li><li>代表：傳統的JavaScript DOM操作。</li><li>例如：使用 getElementById、appendChild、setAttribute 等方法直接操控DOM元素。</li></ul><h2 id="mvc-vs-mvvm" tabindex="-1">MVC vs MVVM <a class="header-anchor" href="#mvc-vs-mvvm" aria-label="Permalink to &quot;MVC vs MVVM&quot;">​</a></h2><h3 id="mvc-model-view-controller" tabindex="-1">MVC（Model-View-Controller） <a class="header-anchor" href="#mvc-model-view-controller" aria-label="Permalink to &quot;MVC（Model-View-Controller）&quot;">​</a></h3><p>屬於指令式渲染，需要手動控制視圖和控制器之間的數據傳遞。</p><table><thead><tr><th>Term</th><th>說明</th></tr></thead><tbody><tr><td>Model（模型）</td><td>儲存在應用程式中的狀態(State)或數據。</td></tr><tr><td>View（視圖）</td><td>顯示給用戶看的畫面。</td></tr><tr><td>Controller（控制器）</td><td>處理用戶的輸入和協調Model和View之間的交互： <br> - 監聽用戶輸入事件（例如按鈕點擊）<br> - 根據用戶輸入更新Model的狀態<br> - 控制View的呈現以反映Model的變化</td></tr></tbody></table><p><a href="https://playcode.io/1605091" target="_blank" rel="noreferrer">看程式</a></p><h3 id="mvvm-model-view-viewmodel" tabindex="-1">MVVM (Model-View-ViewModel) <a class="header-anchor" href="#mvvm-model-view-viewmodel" aria-label="Permalink to &quot;MVVM (Model-View-ViewModel)&quot;">​</a></h3><p>屬於宣告式渲染（Declarative Rendering），開發者無需手動處理數據更新。 在 MVVM 架構中，Model 需要具備反應性(Reactivity)，才能讓 ViewModel 自動更新視圖。 Vue 底層是 proxy，寫程式時可以調用 vue 裡面的 ref、reactive。</p><table><thead><tr><th>Term</th><th>說明</th></tr></thead><tbody><tr><td>Model (模型)</td><td>儲存在 Javascript 裡面的狀態(State)。</td></tr><tr><td>View (視圖)</td><td>顯示給用戶看的畫面(View)。</td></tr><tr><td>ViewModel (視圖模型)</td><td>將 Model 和 View 同步：<br> - 監聽 DOM 事件，自動把受到事件更新的狀態更新到 Model 層。 <br> - 在 Model 改變時渲染出新的 View<br></td></tr></tbody></table><p><img src="https://book.vue.tw/assets/img/1-1-mvvm.febdf1bd.png" alt=""></p><p><a href="https://playcode.io/1605065" target="_blank" rel="noreferrer">看程式</a></p><h3 id="元件結構" tabindex="-1">元件結構 <a class="header-anchor" href="#元件結構" aria-label="Permalink to &quot;元件結構&quot;">​</a></h3><p><img src="https://v2.vuejs.org/images/components.png" alt=""></p><h2 id="reference" tabindex="-1">Reference <a class="header-anchor" href="#reference" aria-label="Permalink to &quot;Reference&quot;">​</a></h2><ul><li><a href="https://vuejs.org/guide/scaling-up/state-management.html" target="_blank" rel="noreferrer">Vue.js-State Management</a></li></ul>',20),o=[i];function d(n,h,s,c,m,v){return t(),a("div",null,o)}const V=e(l,[["render",d]]);export{p as __pageData,V as default};
