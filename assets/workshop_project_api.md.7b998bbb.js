import{_ as s,o as a,c as o,U as p}from"./chunks/framework.c48658f6.js";const u=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"workshop/project/api.md","filePath":"workshop/project/api.md"}'),e={name:"workshop/project/api.md"},t=p('<h2 id="api-集中管理" tabindex="-1">API 集中管理 <a class="header-anchor" href="#api-集中管理" aria-label="Permalink to &quot;API 集中管理&quot;">​</a></h2><p>在純前端專案中，API（應用程式介面）的集中管理非常重要，主要有以下幾個原因：</p><div class="info custom-block"><p class="custom-block-title">1. 程式碼組織與可維護性</p><p>當一個專案中需要調用多個不同的API時，將這些API的調用邏輯分散在各個元件或模組中會導致程式碼雜亂且難以維護。通過集中管理API，可以將所有的API請求邏輯集中在一個地方，使得程式碼結構更加清晰，易於維護和修改。</p></div><div class="info custom-block"><p class="custom-block-title">2. 複用性</p><p>在大型前端專案中，可能會有多個元件或頁面需要調用相同的API。如果每個元件都獨自處理API請求，會導致重複的程式碼，增加了開發和維護的工作量。通過集中管理API，可以提高程式碼的複用性，減少重複程式碼的存在。</p></div><div class="info custom-block"><p class="custom-block-title">3. 易於管理請求和錯誤</p><p>在一個地方處理所有的API的請求和回應，從而更好地管理請求的生命週期，包括請求前的預處理、請求中的攔截和錯誤處理。這樣做可以使錯誤處理更加一致和容易調試，同時也可以更好地記錄和監控API請求。</p></div><div class="info custom-block"><p class="custom-block-title">4. 便於切換API來源</p><p>在開發過程中，可能需要在不同的環境（開發、測試、生產）切換API的來源。如果API調用邏輯分散在各個元件中，切換API來源會變得非常繁瑣。而集中管理API可以輕鬆地在一個地方修改API的基礎URL或配置，從而實現切換API來源的目的。</p></div><p>使用設計模式來輔助實現集中管理API：</p><div class="info custom-block"><p class="custom-block-title">Singleton（單例模式）</p><p>可以使用單例模式確保整個應用程式只有一個API管理實例。這樣做可以確保所有元件都使用相同的API管理物件，避免不同實例之間的資料不一致和衝突。</p></div><div class="info custom-block"><p class="custom-block-title">Facade（外觀模式）</p><p>API管理可以被視為一個外觀模式，它為前端提供了一個簡單易用的介面，屏蔽了底層API請求的複雜性。通過外觀模式，我們可以隱藏API請求的具體實現細節，提供一個更高級別的介面供元件使用。</p></div><div class="info custom-block"><p class="custom-block-title">Proxy（代理模式）</p><p>可以使用代理模式來攔截和處理API請求。通過代理模式，我們可以在請求發送前後執行一些額外的邏輯，比如添加認證資訊、統一處理錯誤等。</p></div><div class="info custom-block"><p class="custom-block-title">Observer（觀察者模式）</p><p>可以使用觀察者模式實現API請求的監聽和通知機制。當API請求完成時，觀察者模式可以通知所有訂閱者，從而實現在不同元件之間傳遞請求結果。</p></div><h2 id="api-製作" tabindex="-1">api 製作 <a class="header-anchor" href="#api-製作" aria-label="Permalink to &quot;api 製作&quot;">​</a></h2><p>安裝 ajax 工具 axios 。</p><div class="vp-code-group"><div class="tabs"><input type="radio" name="group-3q7sh" id="tab-sITTCw0" checked="checked"><label for="tab-sITTCw0">yarn</label><input type="radio" name="group-3q7sh" id="tab-4WWs4I6"><label for="tab-4WWs4I6">npm</label></div><div class="blocks"><div class="language-bash active"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#FFCB6B;">yarn</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">add</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">axios</span></span></code></pre></div><div class="language-bash"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#FFCB6B;">npm</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">install</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">axios</span></span></code></pre></div></div></div><p>文件閱讀 資料表 Dialog Form</p><p>props/event/attribute provide/inject default/named slot component reference async component wrapper component ( redefine props/event ) 父子組件溝通 常見錯誤：v-model 綁定到 props 上</p>',16),l=[t];function c(i,n,r,d,m,b){return a(),o("div",null,l)}const v=s(e,[["render",c]]);export{u as __pageData,v as default};
