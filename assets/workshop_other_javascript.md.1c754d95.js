import{_ as s,o as a,c as n,Q as l}from"./chunks/framework.1eafcbb1.js";const u=JSON.parse('{"title":"All About Javascript","description":"","frontmatter":{},"headers":[],"relativePath":"workshop/other/javascript.md","filePath":"workshop/other/javascript.md"}'),p={name:"workshop/other/javascript.md"},o=l(`<h1 id="all-about-javascript" tabindex="-1">All About Javascript <a class="header-anchor" href="#all-about-javascript" aria-label="Permalink to &quot;All About Javascript&quot;">​</a></h1><ul><li>let const, var</li></ul><h2 id="非同步處理" tabindex="-1">非同步處理 <a class="header-anchor" href="#非同步處理" aria-label="Permalink to &quot;非同步處理&quot;">​</a></h2><p>非同步操作是指在執行程式碼時，不需要等待某個操作完成才繼續執行下一個操作，而是可以同時進行多個操作，並在適當的時機處理它們的結果。 例如：我們想要從網路上下載一張圖片，但是我們不知道這個過程會花多少時間，也不想讓程式卡住等待圖片下載完成，那麼我們就可以使用非同步操作來實現。</p><h3 id="promise" tabindex="-1">Promise <a class="header-anchor" href="#promise" aria-label="Permalink to &quot;Promise&quot;">​</a></h3><p>promise 是一種用來處理非同步操作的語法，它可以讓我們用更簡潔的方式寫出可讀性高的程式碼。 promise 就像是一個承諾，它代表了一個未來會完成或失敗的非同步操作，以及它所產生的值。 我們可以用以下的程式碼來建立一個 promise 物件：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> promise </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">Promise</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">function</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">resolve</span><span style="color:#E1E4E8;">, </span><span style="color:#FFAB70;">reject</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 在這裡執行非同步操作，例如下載圖片</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 如果成功，呼叫 resolve(value) 並傳入結果值</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 如果失敗，呼叫 reject(reason) 並傳入錯誤原因</span></span>
<span class="line"><span style="color:#E1E4E8;">});</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">let</span><span style="color:#24292E;"> promise </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">Promise</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">function</span><span style="color:#24292E;">(</span><span style="color:#E36209;">resolve</span><span style="color:#24292E;">, </span><span style="color:#E36209;">reject</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 在這裡執行非同步操作，例如下載圖片</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 如果成功，呼叫 resolve(value) 並傳入結果值</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 如果失敗，呼叫 reject(reason) 並傳入錯誤原因</span></span>
<span class="line"><span style="color:#24292E;">});</span></span></code></pre></div><p>promise 物件有兩種可能的狀態：</p><ul><li>待定（pending），當 promise 物件被建立時，它的狀態是待定（pending），直到非同步操作完成或失敗為止。</li><li>已實現（fulfilled）</li><li>已拒絕（rejected）</li></ul><h3 id="then" tabindex="-1">then <a class="header-anchor" href="#then" aria-label="Permalink to &quot;then&quot;">​</a></h3><p>當 promise 物件的狀態改變，可以使用 then 方法來註冊回呼函式（callback function），來處理成功或失敗的結果。 then 方法接受兩個參數：</p><ul><li>第一個是成功時要執行的函式</li><li>第二個是失敗時要執行的函式 範例：</li></ul><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">promise.</span><span style="color:#B392F0;">then</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">function</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">value</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 這裡的函式會在 promise 狀態變成已實現時執行，並接收到非同步操作的結果值</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 我們可以在這裡使用結果值來做一些事情，例如顯示圖片</span></span>
<span class="line"><span style="color:#E1E4E8;">}, </span><span style="color:#F97583;">function</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">reason</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 這裡的函式會在 promise 狀態變成已拒絕時執行，並接收到非同步操作的錯誤原因</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 我們可以在這裡處理錯誤，例如顯示錯誤訊息</span></span>
<span class="line"><span style="color:#E1E4E8;">});</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">promise.</span><span style="color:#6F42C1;">then</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">function</span><span style="color:#24292E;">(</span><span style="color:#E36209;">value</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 這裡的函式會在 promise 狀態變成已實現時執行，並接收到非同步操作的結果值</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 我們可以在這裡使用結果值來做一些事情，例如顯示圖片</span></span>
<span class="line"><span style="color:#24292E;">}, </span><span style="color:#D73A49;">function</span><span style="color:#24292E;">(</span><span style="color:#E36209;">reason</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 這裡的函式會在 promise 狀態變成已拒絕時執行，並接收到非同步操作的錯誤原因</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 我們可以在這裡處理錯誤，例如顯示錯誤訊息</span></span>
<span class="line"><span style="color:#24292E;">});</span></span></code></pre></div><h3 id="chaining-promise" tabindex="-1">Chaining Promise <a class="header-anchor" href="#chaining-promise" aria-label="Permalink to &quot;Chaining Promise&quot;">​</a></h3><p>then 方法會回傳一個新的 promise 物件，所以我們可以將多個 then 方法串連起來，形成一個鏈式結構（promise chain）。 讓我們可以依序執行多個非同步操作，並將前一個操作的結果傳遞給下一個操作，例如：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">promise.</span><span style="color:#B392F0;">then</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">function</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">value</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 做第一件事情</span></span>
<span class="line"><span style="color:#E1E4E8;">}).</span><span style="color:#B392F0;">then</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">function</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">value</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 做第二件事情</span></span>
<span class="line"><span style="color:#E1E4E8;">}).</span><span style="color:#B392F0;">then</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">function</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">value</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 做第三件事情</span></span>
<span class="line"><span style="color:#E1E4E8;">});</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">promise.</span><span style="color:#6F42C1;">then</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">function</span><span style="color:#24292E;">(</span><span style="color:#E36209;">value</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 做第一件事情</span></span>
<span class="line"><span style="color:#24292E;">}).</span><span style="color:#6F42C1;">then</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">function</span><span style="color:#24292E;">(</span><span style="color:#E36209;">value</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 做第二件事情</span></span>
<span class="line"><span style="color:#24292E;">}).</span><span style="color:#6F42C1;">then</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">function</span><span style="color:#24292E;">(</span><span style="color:#E36209;">value</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 做第三件事情</span></span>
<span class="line"><span style="color:#24292E;">});</span></span></code></pre></div><h3 id="catch" tabindex="-1">catch <a class="header-anchor" href="#catch" aria-label="Permalink to &quot;catch&quot;">​</a></h3><p>如果在鏈式結構中的任何一個操作失敗了，我們可以使用 catch 方法來捕捉錯誤，並統一處理。 catch 方法會接收一個參數，就是失敗時要執行的函式，例如：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">promise.</span><span style="color:#B392F0;">then</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">function</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">value</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 做第一件事情</span></span>
<span class="line"><span style="color:#E1E4E8;">}).</span><span style="color:#B392F0;">then</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">function</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">value</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 做第二件事情</span></span>
<span class="line"><span style="color:#E1E4E8;">}).</span><span style="color:#B392F0;">then</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">function</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">value</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 做第三件事情</span></span>
<span class="line"><span style="color:#E1E4E8;">}).</span><span style="color:#B392F0;">catch</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">function</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">reason</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 處理任何一個操作的錯誤</span></span>
<span class="line"><span style="color:#E1E4E8;">});</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">promise.</span><span style="color:#6F42C1;">then</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">function</span><span style="color:#24292E;">(</span><span style="color:#E36209;">value</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 做第一件事情</span></span>
<span class="line"><span style="color:#24292E;">}).</span><span style="color:#6F42C1;">then</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">function</span><span style="color:#24292E;">(</span><span style="color:#E36209;">value</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 做第二件事情</span></span>
<span class="line"><span style="color:#24292E;">}).</span><span style="color:#6F42C1;">then</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">function</span><span style="color:#24292E;">(</span><span style="color:#E36209;">value</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 做第三件事情</span></span>
<span class="line"><span style="color:#24292E;">}).</span><span style="color:#6F42C1;">catch</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">function</span><span style="color:#24292E;">(</span><span style="color:#E36209;">reason</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 處理任何一個操作的錯誤</span></span>
<span class="line"><span style="color:#24292E;">});</span></span></code></pre></div><h3 id="async-await" tabindex="-1">async/await <a class="header-anchor" href="#async-await" aria-label="Permalink to &quot;async/await&quot;">​</a></h3><ul><li>async：關鍵字，它可以用來宣告一個函式是非同步的，也就是說它會回傳一個 promise 物件</li><li>await：關鍵字，它可以用來等待一個非同步操作完成，也就是說它會等待一個 promise 物件的實現或拒絕。</li></ul><p>async 和 await 是在 ES2017 中加入的新語法，它們是基於 promise 之上的語法糖，用更接近同步的方式寫出非同步的程式碼。 async/await 優點：</p><ul><li>不需要使用 then 和 catch 方法來註冊回呼函式，直接使用變數來存取非同步操作的結果值或錯誤原因。</li><li>try/catch 方法可以用來捕捉非同步操作的錯誤，並處理錯誤，例如顯示錯誤訊息。 P.S. 目前不支援 top-level await，因此 await 只能在 async 函式中使用，否則會產生語法錯誤。</li></ul><p>範例：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">async</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">function</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">downloadImage</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">url</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 在這裡執行非同步操作，例如下載圖片</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 如果成功，回傳結果值</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 如果失敗，拋出錯誤原因</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">async</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">function</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">showImage</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">url</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">try</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 使用 await 等待非同步操作的完成，並將結果值存入變數中</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> image </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">await</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">downloadImage</span><span style="color:#E1E4E8;">(url);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 使用結果值來做一些事情，例如顯示圖片</span></span>
<span class="line"><span style="color:#E1E4E8;">  } </span><span style="color:#F97583;">catch</span><span style="color:#E1E4E8;"> (error) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 使用 try...catch 語句來捕捉錯誤，並處理錯誤，例如顯示錯誤訊息</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">async</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">function</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">downloadImage</span><span style="color:#24292E;">(</span><span style="color:#E36209;">url</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 在這裡執行非同步操作，例如下載圖片</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 如果成功，回傳結果值</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 如果失敗，拋出錯誤原因</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D73A49;">async</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">function</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">showImage</span><span style="color:#24292E;">(</span><span style="color:#E36209;">url</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">try</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 使用 await 等待非同步操作的完成，並將結果值存入變數中</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">let</span><span style="color:#24292E;"> image </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">await</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">downloadImage</span><span style="color:#24292E;">(url);</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 使用結果值來做一些事情，例如顯示圖片</span></span>
<span class="line"><span style="color:#24292E;">  } </span><span style="color:#D73A49;">catch</span><span style="color:#24292E;"> (error) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 使用 try...catch 語句來捕捉錯誤，並處理錯誤，例如顯示錯誤訊息</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>// 這樣可以讓我們的程式碼更簡潔、更易讀、更易維護</p><p>// 日常生活類比舉例 // 我們可以把 promise 比喻成訂購外送餐點的過程，當我們打電話訂購時，店家會給我們一個預計送達的時間，這就像是建立一個 promise 物件 // 然後我們可以繼續做自己的事情，不需要等待餐點送到才繼續執行下一個動作，這就像是非同步操作 // 當餐點送到時，我們可以拿到餐點並享用，這就像是 promise 狀態變成已實現時執行 then 方法中的函式 // 如果餐點沒有送到或送錯了，我們可以打電話投訴或取消訂單，這就像是 promise 狀態變成已拒絕時執行 catch 方法中的函式</p><p>// 我們可以把 async 和 await 比喻成在辦公室工作的</p><ul><li>anonymous(arrow) function</li><li>Asynchronous JavaScript/Promise ( async/await vs then ) (<a href="https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Asynchronous" target="_blank" rel="noreferrer">https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Asynchronous</a>)</li><li>prototype/class/static</li></ul><h2 id="reference" tabindex="-1">Reference <a class="header-anchor" href="#reference" aria-label="Permalink to &quot;Reference&quot;">​</a></h2><p>-<a href="https://www.freecodecamp.org/news/javascript-design-patterns-explained/" target="_blank" rel="noreferrer">Javascript patterns</a> -<a href="https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Asynchronous" target="_blank" rel="noreferrer">Asynchronous JavaScript/Promise ( async/await vs then )</a></p>`,31),e=[o];function c(t,r,E,y,i,h){return a(),n("div",null,e)}const A=s(p,[["render",c]]);export{u as __pageData,A as default};
